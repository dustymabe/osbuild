#!/usr/bin/python3
"""
OSTree deployment mount service

This mount service will setup all needed bind mounts so
that a given `tree` will look like an active OSTree
deployment, very much as OSTree does during early boot.

More specifically it will:
  - setup the sysroot bindmount to the deployment
  - setup the shared var directory
  - bind the boot directory into the deployment

Host commands used: mount
"""

import os
import subprocess
import sys
from typing import Dict

from osbuild import mounts
from osbuild.util import ostree

SCHEMA_2 = """
"additionalProperties": false,
"required": ["name", "type"],
"properties": {
  "name": { "type": "string" },
  "type": { "type": "string" },
  "options": {
    "type": "object",
    "required": ["deployment"],
    "properties": {
      "source": {
        "type": "string",
        "pattern": "^(mount|tree)$",
        "default": "tree",
        "description": "The source of the OSTree filesystem tree"
      },
      "deployment": {
        "type": "object",
        "additionalProperties": false,
        "required": ["osname", "ref"],
        "properties": {
          "osname": {
            "description": "Name of the stateroot to be used in the deployment",
            "type": "string"
          },
          "ref": {
            "description": "OStree ref to create and use for deployment",
            "type": "string"
          },
          "serial": {
            "description": "The deployment serial (usually '0')",
            "type": "number",
            "default": 0
          }
        }
      }
    }
  }
}
"""


class OSTreeDeploymentMount(mounts.MountService):

    def __init__(self, args):
        super().__init__(args)

        self.mountpoint = None
        self.check = False

    @staticmethod
    def bind_mount(source, target):
        subprocess.run([
            "mount", "--bind", "--make-private", source, target,
        ], check=True)

    def mount(self, args: Dict):

        tree = args["tree"]
        mountroot = args["root"]
        options = args["options"]


        source = options.get("source", "tree")
        deployment = options["deployment"]
        osname = deployment["osname"]
        ref = deployment["ref"]
        serial = deployment.get("serial", 0)

        # The user could specify either the tree or mountroot as the
        # place where we want the deployment to be mounted.
        if source == "mount":
            target = mountroot
        else:
            target = tree

        # create a private mountpoint for the target path, which is
        # needed in order to be able to move the deployment `root`
        # mountpoint here, which is contained inside tree, since
        # "moving a mount residing under a shared mount is invalid
        # and unsupported."
        #                                              - `mount(8)`
        self.bind_mount(target, target)

        deploy_root = ostree.deployment_path(target, osname, ref, serial)

        print(f"Deployment root at '{os.path.relpath(deploy_root, target)}'")

        var = os.path.join(target, "ostree", "deploy", osname, "var")
        boot = os.path.join(target, "boot")

        self.mountpoint = deploy_root
        self.bind_mount(deploy_root, deploy_root)  # prepare to move it later

        self.bind_mount(target, os.path.join(deploy_root, "sysroot"))
        self.bind_mount(var, os.path.join(deploy_root, "var"))
        self.bind_mount(boot, os.path.join(deploy_root, "boot"))

        subprocess.run([
            "mount", "--move", deploy_root, target,
        ], check=True)

        self.mountpoint = target
        self.check = True

    def umount(self):
        if self.mountpoint:
            print(f"umounting {self.mountpoint}")
            subprocess.run(["sync", "-f", self.mountpoint],
                           check=self.check)
            subprocess.run(["umount", "-R", self.mountpoint],
                           check=self.check)
            self.mountpoint = None


def main():
    service = OSTreeDeploymentMount.from_args(sys.argv[1:])
    service.main()


if __name__ == '__main__':
    main()
